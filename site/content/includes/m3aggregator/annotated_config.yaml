# Logging configuration
# TODO: More detail than this 
# https://github.com/m3db/m3/blob/9f129cf9f16430cc5a399f60aa5684fb72b55bb5/src/cmd/services/m3query/config/config.go#L116
# Configuration for logging.
logging:
  # Log file location
  file: <string>
  # Error logging level
  level: <string>
  # TODO: ??
  fields:

# Metrics configuration
# TODO: Which is what?
metrics:
  # Scope of metrics root
  # TODO: Again, which is?
  scope:
    # Prefix prepended to metrics collected
    prefix: <string>
    # Reporting frequendy of metrics collected
    reportingInterval: <duration>
    # Tags shared by metrics collected
    tags: <map of strings>
  # Configuration for a Prometheus reporter (if used)
  prometheus:
    # Metrics collection endpoint for application
    # Default = "/metrics"
    handlerPath: <string>
    # Listen address for metrics
    # Default = "0.0.0.0:7203"
    listenAddress: <url>
    # The default Prometheus type to use for Tally timers
    # TODO: What are the options?
    timerType: <string>
    # If specified, sets the default histogram buckets used by the reporter
    defaultHistogramBuckets:
      # TODO: Which means?
      upper: <float>
    # If specified sets the default summary objectives used by the reporter
    defaultSummaryObjectives:
      percentile: <float>
      allowedError: <float>
    # What to do with errors when listening on the specified listen address or registering a metric with Prometheus. By default the registerer panics
    # TODO: Specifies how?
    onError: <string>
  # Metric sanitization type, valid options: [none, m3, prometheus]
  # Default = "none"
  sanitization: <string>
  # Sampling rate for metrics. min=0.0, max=1.0
  # TODO: What does this mean exactly?
  samplingRate: <float>
  # Enable Go runtime metrics, valid options: [none, simple, moderate, detailed]
  # See https://github.com/m3db/m3/blob/master/src/x/instrument/extended.go#L39:L64 for more details
  extended: <string>

# HTTP server configuration 
http:
  # Listening address
  listenAddress: <url>
  # Read timeout
  readTimeout: <duration>
  # Write timeout
  writeTimeout: <duration>

rawtcp:
  # The raw TCP server listen address
  listenAddress: <url>
  # Keep connections alive
  keepAliveEnabled: <bool>
  # Keep connections alive duration
  keepAlivePeriod: <duration>
  retry:
    initialBackoff: <duration>
    # Factor for exponential backoff
    backoffFactor: <float>
    # Maximum backoff time
    maxBackoff: <duration>
    # Maximum retry attempts
    maxRetries: <int>
    # Retry connection forever until the attempt succeeds, or the retry condition becomes false
    forever: <bool>    
    # Add randomness to wait intervals
    jitter: <bool>  
  readBufferSize: <int>
  # Configuration for protobuf unaggregated iterator
  protobufIterator:
    # Initial buffer size
    initBufferSize: <int>
    # Maximum message size
    # Max is 50MB
    maxMessageSize: <int>
    # Bucketized pool configuration
    bytesPool:
      # Configuration for buckets in a pool
      buckets:
        # Number of items in the bucket
        count: <int>
        # Capacity of each item in the bucket
        capacity: <int>
      watermark:
        # The low watermark to start refilling the pool
        # min=0.0, max=1.0
        low: <float>
        # The high watermark to start refilling the pool
        # min=0.0, max=1.0
        high: <float>

# Client configuration for key value store
kvClient:
  # etcd client configuration
  etcd:
    # TODO: ?
    env: default_env
    # Availability zone, valid options: [user-defined, embedded]
    zone: <string>
    # TODO: ??
    service: m3db
    # Directory to store cached etcd data
    cacheDir: <string>
    # Identify the etcd hosts this node should connect to
    # TODO: Fill this in
    etcdClusters:
      - zone: embedded
        endpoints:
          - m3db_seed:2379
    # TODO: What is this?
    m3sd:
      initTimeout: <duration>
    # The revision that watch requests start from
    watchWithRevision: <int>
    # Changes permissions and mode of cache directory
    newDirectoryMode: <string>
    # Configuration for retrying connection operations
    retry:
      initialBackoff: <duration>
      # Factor for exponential backoff
      backoffFactor: <float>
      # Maximum backoff time
      maxBackoff: <duration>
      # Maximum retry attempts
      maxRetries: <int>
      # Retry connection forever until the attempt succeeds, or the retry condition becomes false
      forever: <bool>      
      # Add randomness to wait intervals
      jitter: <bool>
    # The timeout for etcd requests
    requestTimeout: <duration>
    # The timeout for a watchChan initialization
    watchChanInitTimeout: <duration>
    # Frequency to check if a watch chan is no longer subscribed and should be closed
    watchChanCheckInterval: <duration>
    # The delay before resetting the etcd watch chan
    watchChanResetInterval: <duration>

# Runtime configuration
runtimeOptions:
  # Override values for placement
  kvConfig:
    zone: <string>
    environment: <string>
    namespace: <string>
  # TODO: What do these mean?
  writeValuesPerMetricLimitPerSecondKey: <string>
  writeValuesPerMetricLimitPerSecond: <int>
  writeNewMetricLimitClusterPerSecondKey: <string>
  writeNewMetricLimitClusterPerSecond: <int>
  writeNewMetricNoLimitWarmupDuration: <duration>

# Aggregator configuration
aggregator:
  # Configuration for resolving a host ID
  hostID:
    # Resolver used for the host ID, valid options: [hostname, config, environment, file]
    # TODO: This will need a reference link or something
    resolver: <string>
    # The config specified host ID if using config host ID resolver
    value: <string>
    # The environment specified host ID if using environment host ID resolver
    envVarName: <string>
    # A file containing the info needed for the host ID
    file:
      # Path to the file containing host ID
      path: <string>
      # Timeout to wait for the file to be non-empty.
      timeout: <duration>
    # Resolves host using the hostname returned by the OS
    hostname: <string>
  # Instance ID configuration
  instanceID:
    # Specifies how to construct the instance ID used for lookup of the aggregator in the placement, valid options: [host_id, host_id_port]
    type: <string>
  # Common metric prefix
  metricPrefix: <string>
  # Counter metric prefix
  counterPrefix: <string>
  # Timer metric prefix
  timerPrefix: <string>
  # Gauge metric prefix
  gaugePrefix: <string>
  # Configuration for aggregation types
  aggregationTypes:
    # TODO: Are the below typeStringNames etc?
    # Default aggregation types for counter metrics
    defaultCounterAggregationTypes:
    # Default aggregation types for timer metrics
    defaultTimerAggregationTypes:
    # Default aggregation types for gauge metrics
    defaultGaugeAggregationTypes:
    # Configures the type string transformation function for counters, valid options: [noop, empty, suffix]
    counterTransformFnType: <string>
    # Configures the type string transformation function for timers, valid options: [noop, empty, suffix]
    timerTransformFnType: <string>
    # Configures the type string transformation function for gauges, valid options: [noop, empty, suffix]
    gaugeTransformFnType: <string>
    # Pool of aggregation types
    aggregationTypesPool:
      # Size of the pool
      size: <int>
      watermark:
        # The low watermark to start refilling the pool
        # min=0.0, max=1.0
        low: <float>
        # The high watermark to start refilling the pool
        # min=0.0, max=1.0
        high: <float>
    # Pool of quantile slices.
    quantilesPool:
      # Configuration for buckets in a pool
      buckets:
        # Number of items in the bucket
        count: <int>
        # Capacity of each item in the bucket
        capacity: <int> 
  # Pool of streams
  # TODO: Which means?
  stream:
    # Error epsilon for quantile computation
    eps: <float>
    # Initial heap capacity for quantile computation
    capacity: <int>
    # Insertion and compression frequency
    insertAndCompressEvery: <int>
    # Flush frequency
    flushEvery: <int>
    # TODO: Each of the below, what do they actually mean?
    # Pool of streams
    streamPool:
      size: <int>
      # Pool watermark configuration
      watermark:
        # The low watermark to start refilling the pool
        # min=0.0, max=1.0
        low: <float>
        # The high watermark to start refilling the pool
        # min=0.0, max=1.0
        high: <float>
    # Pool of metric samples 
    samplePool:
      size: <int>
      # Pool watermark configuration
      watermark:
        # The low watermark to start refilling the pool
        # min=0.0, max=1.0
        low: <float>
        # The high watermark to start refilling the pool
        # min=0.0, max=1.0
        high: <float>
    # Pool of float slices
    floatsPool:
      # Configuration for buckets in a pool
      buckets:
        # Number of items in the bucket
        count: <int>
        # Capacity of each item in the bucket
        capacity: <int>
      watermark:
        # The low watermark to start refilling the pool
        # min=0.0, max=1.0
        low: <float>
        # The high watermark to start refilling the pool
        # min=0.0, max=1.0
        high: <float>
  # Aggregator client configuration
  client:
    # The aggregator client type, valid options: [legacy, m3msg, tcp]
    type: <string>
    # Required configuration if using the m3msg client type
    m3msg:
      producer:
        # Buffer configuration for m3msg client type
        buffer:
          # TODO: Not sure
          onFullStrategy:
          maxBufferSize: <int>
          maxMessageSize: <int>
          closeCheckInterval: <duration>
          dropOldestInterval: <duration>
          scanBatchSize: <int>
          allowedSpilloverRatio: <float>
          #  Cleanup retry configuration
          cleanupRetry:
            initialBackoff: <duration>
            # Factor for exponential backoff
            backoffFactor: <float>
            # Maximum backoff time
            maxBackoff: <duration>
            # Maximum retry attempts
            maxRetries: <int>
            # Retry connection forever until the attempt succeeds, or the retry condition becomes false
            forever: <bool>    
            # Add randomness to wait intervals
            jitter: <bool>
        # Writer configuration for m3msg client type
        writer:
          topicName: <string>
          topicServiceOverride:
          topicWatchInitTimeout: <duration>
          # Placement options
          placement:
            allowPartialReplace: <bool>
            allowAllZones: <bool>
            addAllCandidates: <bool>
            isSharded: <bool>
            # The mode to manage shard state in the placement
            # TODO: Values?
            shardStateMode:
            isMirrored: <bool>
            isStaged: <bool>
            validZone: <string>
          # Override configuration for namespace options
          placementServiceOverride:
            namespaces:
              placement: <string>
              metadata: <string>
          placementWatchInitTimeout: <duration>
          messagePool:
            size: <int>
            # Pool watermark configuration
            watermark:
              # The low watermark to start refilling the pool
              # min=0.0, max=1.0
              low: <float>
              # The high watermark to start refilling the pool
              # min=0.0, max=1.0
              high: <float>
          # Message retry configuration
          messageRetry:
            initialBackoff: <duration>
            # Factor for exponential backoff
            backoffFactor: <float>
            # Maximum backoff time
            maxBackoff: <duration>
            # Maximum retry attempts
            maxRetries: <int>
            # Retry connection forever until the attempt succeeds, or the retry condition becomes false
            forever: <bool> 
            # Add randomness to wait intervals
            jitter: <bool>
          messageQueueNewWritesScanInterval: <duration>
          messageQueueFullScanInterval: <int>
          messageQueueScanBatchSize: <int>
          initialAckMapSize: <int>
          closeCheckInterval: <duration>
          # Acknowledging error retry configuration
          ackErrorRetry:
            initialBackoff: <duration>
            # Factor for exponential backoff
            backoffFactor: <float>
            # Maximum backoff time
            maxBackoff: <duration>
            # Maximum retry attempts
            maxRetries: <int>
            # Retry connection forever until the attempt succeeds, or the retry condition becomes false
            forever: <bool>   
            # Add randomness to wait intervals
            jitter: <bool>            
          encoder:
            maxMessageSize: <int>
            # Bucketized pool configuration
            bytesPool:
              # Configuration for buckets in a pool
              buckets:
                # Number of items in the bucket
                count: <int>
                # Capacity of each item in the bucket
                capacity: <int>
              watermark:
                # The low watermark to start refilling the pool
                # min=0.0, max=1.0
                low: <float>
                # The high watermark to start refilling the pool
                # min=0.0, max=1.0
                high: <float>
          decoder:
            maxMessageSize: <int>
            # Bucketized pool configuration
            bytesPool:
              # Configuration for buckets in a pool
              buckets:
                # Number of items in the bucket
                count: <int>
                # Capacity of each item in the bucket
                capacity: <int>
              watermark:
                # The low watermark to start refilling the pool
                # min=0.0, max=1.0
                low: <float>
                # The high watermark to start refilling the pool
                # min=0.0, max=1.0
                high: <float>
          # Connection options
          connection:
            numConnections: <int>
            dialTimeout: <duration>
            writeTimeout: <duration>
            keepAlivePeriod: <duration>
            resetDelay: <duration>
            retry:
              initialBackoff: <duration>
              # Factor for exponential backoff
              backoffFactor: <float>
              # Maximum backoff time
              maxBackoff: <duration>
              # Maximum retry attempts
              maxRetries: <int>
              # Retry connection forever until the attempt succeeds, or the retry condition becomes false
              forever: <bool>
              # Add randomness to wait intervals
              jitter: <bool>                 
            flushInterval: <duration>
            writeBufferSize: <int>
            readBufferSize: <int>
    # Override values for placement
    placementKV:
      zone: <string>
      environment: <string>
      namespace: <string>
    # Placement watcher configuration
    # TODO: Which is?
    placementWatcher:
      # Placement key
      key: <string>
      # Initial watch timeout
      initWatchTimeout: <duration>
    # Hashing type, valid options: [murmu32, zero] 
    hashType: <string>
    # TODO: What are the below?
    shardCutoverWarmupDuration: <duration>
    shardCutoffLingerDuration: <duration>
    # Encoder configuration
    encoder:
      # Initial buffer size
      initBufferSize: <int>
      maxMessageSize: <int>
      # Bucketized pool configuration
      bytesPool:
        # Configuration for buckets in a pool
        buckets:
          # Number of items in the bucket
          count: <int>
          # Capacity of each item in the bucket
          capacity: <int>
        watermark:
          # The low watermark to start refilling the pool
          # min=0.0, max=1.0
          low: <float>
          # The high watermark to start refilling the pool
          # min=0.0, max=1.0
          high: <float>
    # Buffer size to trigger a flush
    flushSize: <int>
    # The maximum buffer size that triggers a queue drain
    maxBatchSize: <int>
    # The maximum timer batch size
    maxTimerBatchSize: <int>
    # The deadline that triggers a write of queued buffers
    batchFlushDeadline: <duration>
    # Queue size
    queueSize: <int>
    # The strategy for which metrics should be dropped when the queue is full, valid options: [oldest, current]
    # Default = oldest
    queueDropType: <string>
    # Connection configuration
    connection:
      # Timeout for establishing a connection
      connectionTimeout: <duration>
      # Set a keep-alive http header on the connection
      connectionKeepAlive: <bool>
      # Timeout for writing data
      writeTimeout: <duration>
      # Initial threshold for re-establshing connections
      initReconnectThreshold: <int>
      # Max threshold for re-establishing connections
      maxReconnectThreshold: <int>
      # Threshold multiplier
      # TODO: What does that mean
      reconnectThresholdMultiplier: <int>
      # Max duration between attempts to re-establish connections
      maxReconnectDuration: <duration>
      writeRetries:
        initialBackoff: <duration>
        # Factor for exponential backoff
        backoffFactor: <float>
        # Maximum backoff time
        maxBackoff: <duration>
        # Maximum retry attempts
        maxRetries: <int>
        # Retry connection forever until the attempt succeeds, or the retry condition becomes false
        forever: <bool>
        # Add randomness to wait intervals
        jitter: <bool>
  # Placement manager (reponsible for topography) configuration
  placementManager:
    # TODO: This is in a lot of places, what does it mean?
    kvConfig:
      namespace: /placement
      environment: default_env
      zone: embedded
    # TODO: Which is?
    placementWatcher:
      # Placement key
      key: <string>
      # Initial watch timeout
      initWatchTimeout: <duration>
  # Hashing type, valid options: [murmu32, zero] 
  hashType: <string>
  # Duration for buffering writes before shard cutover
  bufferDurationBeforeShardCutover: <duration>
  # Duration for buffering writes after shard cutoff
  bufferDurationAfterShardCutoff: <duration>
  # Resign timout
  # TODO: Resign of what?
  resignTimeout: <duration>
  # TODO: Flush times manager?
  flushTimesManager:
    # TODO: As above
    kvConfig:
      environment: default_env
      zone: embedded
    # Flush times key format
    flushTimesKeyFmt: <string>
    # Retrier for persisting flush times
    flushTimesPersistRetrier:
      initialBackoff: <duration>
      # Factor for exponential backoff
      backoffFactor: <float>
      # Maximum backoff time
      maxBackoff: <duration>
      # Maximum retry attempts
      maxRetries: <int>
      # Retry connection forever until the attempt succeeds, or the retry condition becomes false
      forever: <bool>
      # Add randomness to wait intervals
      jitter: <bool>
  # Election manager configuration
  electionManager:
    # Election timeouts and TTLs
    election:
      leaderTimeout: <duration>
      resignTimeout: <duration>
      ttlSeconds: <int>
    # TODO: Service ID configuration
    serviceID:
      name: <string>
      environment: <string>
      zone: <string>
    # Election times key format  
    electionKeyFmt: <string>
    # Retrier for election campaigns
    campaignRetrier:
      initialBackoff: <duration>
      # Factor for exponential backoff
      backoffFactor: <float>
      # Maximum backoff time
      maxBackoff: <duration>
      # Maximum retry attempts
      maxRetries: <int>
      # Retry connection forever until the attempt succeeds, or the retry condition becomes false
      forever: <bool>
      # Add randomness to wait intervals
      jitter: <bool>
    # Change retrier
    changeRetrier:
      initialBackoff: <duration>
      # Factor for exponential backoff
      backoffFactor: <float>
      # Maximum backoff time
      maxBackoff: <duration>
      # Maximum retry attempts
      maxRetries: <int>
      # Retry connection forever until the attempt succeeds, or the retry condition becomes false
      forever: <bool>
      # Add randomness to wait intervals
      jitter: <bool>
    # Resign retrier
    resignRetrier:
      initialBackoff: <duration>
      # Factor for exponential backoff
      backoffFactor: <float>
      # Maximum backoff time
      maxBackoff: <duration>
      # Maximum retry attempts
      maxRetries: <int>
      # Retry connection forever until the attempt succeeds, or the retry condition becomes false
      forever: <bool>
      # Add randomness to wait intervals
      jitter: <bool>
    # Interval to check campaign state
    campaignStateCheckInterval: <duration>
    # Offset when checking if a shard has been cutoff.
    # The cutoff time is applied in order to stop campaignining when necessary before all
    # shards are cut off avoiding incomplete data to be flushed.
    shardCutoffCheckOffset: <duration>
  # Flush manager configuration
  # TODO: Which is?
  flushManager:
    # Check period
    checkEvery: <duration>
    # Enable jitter
    jitterEnabled: <bool>
    # Max jitter percent for lists whose flush intervals are no more than the bucket flush interval
    maxJitters:
      - flushInterval: <duration>
        maxJitterPercent: <float>
    # Number of workers per CPU
    numWorkersPerCPU: <float>
    # How frequently the flush times are persisted
    flushTimesPersistEvery: <duration>
    # Maximum buffer size
    maxBufferSize: <duration>
    # Window size for a forced flush
    forcedFlushWindowSize: <duration> 
  flush:
    # Flush handlers
    # Options are static or dynamic
    # TODO: Which are?
    handlers:
      - staticBackend:
      - dynamicBackend:
          # Name
          name: <string>
          # Hashing type, valid options: [murmu32, zero] 
          hashType: <string>
          producer:
            # Buffer configuration for m3msg client type
            buffer:
              # TODO: Not sure
              onFullStrategy:
              maxBufferSize: <int>
              maxMessageSize: <int>
              closeCheckInterval: <duration>
              dropOldestInterval: <duration>
              scanBatchSize: <int>
              allowedSpilloverRatio: <float>
              #  Cleanup retry configuration
              cleanupRetry:
                initialBackoff: <duration>
                # Factor for exponential backoff
                backoffFactor: <float>
                # Maximum backoff time
                maxBackoff: <duration>
                # Maximum retry attempts
                maxRetries: <int>
                # Retry connection forever until the attempt succeeds, or the retry condition becomes false
                forever: <bool>    
                # Add randomness to wait intervals
                jitter: <bool>
            # Writer configuration for m3msg client type
            writer:
              topicName: <string>
              topicServiceOverride:
              topicWatchInitTimeout: <duration>
              # Placement options
              placement:
                allowPartialReplace: <bool>
                allowAllZones: <bool>
                addAllCandidates: <bool>
                isSharded: <bool>
                # The mode to manage shard state in the placement
                # TODO: Values?
                shardStateMode:
                isMirrored: <bool>
                isStaged: <bool>
                validZone: <string>
  # Write forwarding configuration
  # TODO: Which is?
  forwarding:
    # Maximum delay for a single forward step
    maxSingleDelay: <duration>
    # Maximum delay for a forward step as a constant + resolution*numForwardedTimes.
    maxConstDelay: <duration>
  # How long an entry remains alive before it is expired due to inactivity
  entryTTL: <duration>
  # Interval for checking expired entries
  entryCheckInterval: <duration>
  # Batch percentage for checking expired entries.
  maxTimerBatchSizePerWrite: <float>
  # Default storage policies
  # TODO: Default for what?
  defaultStoragePolicies:
    # In the pattern resolution:retention, e.g. 10s:2d
  # Maximum number of cached source sets.
  maxNumCachedSourceSets: <int>
  # Whether to discard NaN aggregated values
  discardNaNAggregatedValues: <bool>
  # Entry pool
  # TODO: Which is?
  entryPool:
    # Size of the pool
    size: <int>
    watermark:
      # The low watermark to start refilling the pool
      # min=0.0, max=1.0
      low: <float>
      # The high watermark to start refilling the pool
      # min=0.0, max=1.0
      high: <float>
  # Counter element pool
  # TODO: Which is?    
  counterElemPool:
    # Size of the pool
    size: <int>
    watermark:
      # The low watermark to start refilling the pool
      # min=0.0, max=1.0
      low: <float>
      # The high watermark to start refilling the pool
      # min=0.0, max=1.0
      high: <float>
  # Timer element pool
  # TODO: Which is?    
  timerElemPool:
    # Size of the pool
    size: <int>
    watermark:
      # The low watermark to start refilling the pool
      # min=0.0, max=1.0
      low: <float>
      # The high watermark to start refilling the pool
      # min=0.0, max=1.0
      high: <float>
  # Gauge element pool
  # TODO: Which is?    
  gaugeElemPool:
    # Size of the pool
    size: <int>
    watermark:
      # The low watermark to start refilling the pool
      # min=0.0, max=1.0
      low: <float>
      # The high watermark to start refilling the pool
      # min=0.0, max=1.0
      high: <float>
